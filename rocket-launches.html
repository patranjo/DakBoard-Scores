<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upcoming Launches</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600&family=Space+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: 'Oxanium', sans-serif;
            color: #e0e0e0;
            padding: 1rem;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
        }

        .rocket-icon {
            font-size: 1.2rem;
        }

        h1 {
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #64c8ff;
        }

        .launches {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .launch {
            display: grid;
            grid-template-columns: 70px 1fr auto;
            gap: 0.75rem;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .launch:last-child {
            border-bottom: none;
        }

        .countdown {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: #64c8ff;
        }

        .launch-info {
            overflow: hidden;
            min-width: 0;
        }

        .mission-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .details {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .date-time {
            text-align: right;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: #a0e0ff;
            white-space: nowrap;
        }

        .loading, .error {
            text-align: center;
            padding: 1rem;
            font-size: 0.8rem;
            color: rgba(160, 224, 255, 0.6);
        }

        .error {
            color: #ff6464;
        }

        .launch.success {
            background: rgba(0, 200, 100, 0.15);
            border-left: 3px solid #00c864;
            padding-left: 0.5rem;
            margin-left: -0.5rem;
        }

        .launch.success .countdown {
            color: #00c864;
        }

        .launch.failure {
            background: rgba(255, 80, 80, 0.15);
            border-left: 3px solid #ff5050;
            padding-left: 0.5rem;
            margin-left: -0.5rem;
        }

        .launch.failure .countdown {
            color: #ff5050;
        }
    </style>
</head>
<body>
    <div class="header">
        <span class="rocket-icon">ðŸš€</span>
        <h1>Upcoming Launches</h1>
    </div>
    
    <div class="launches" id="launches">
        <div class="loading">Loading...</div>
    </div>

    <script>
        const UPCOMING_URL = 'https://ll.thespacedevs.com/2.2.0/launch/upcoming/?limit=10';
        const PREVIOUS_URL = 'https://ll.thespacedevs.com/2.2.0/launch/previous/?limit=10';
        const TWELVE_HOURS = 12 * 60 * 60 * 1000;
        
        function getCountdown(launchDate) {
            const now = new Date();
            const launch = new Date(launchDate);
            const diff = launch - now;
            
            if (diff < 0) return 'LAUNCHED';
            
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            
            if (days > 0) return `T-${days}d ${hours}h`;
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return `T-${hours}h ${minutes}m`;
        }

        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const month = date.toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
            const day = date.getDate();
            const time = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            return `${month} ${day} ${time}`;
        }

        function shortenLocation(location) {
            if (!location) return 'TBD';
            return location
                .replace(/, United States of America/g, '')
                .replace(/, People's Republic of China/g, '')
                .replace(/, New Zealand/g, '')
                .replace(/Space Launch Complex/g, 'SLC')
                .replace(/Launch Complex/g, 'LC')
                .replace(/Vandenberg.*Base/g, 'Vandenberg')
                .replace(/Kennedy Space Center/g, 'KSC')
                .replace(/Cape Canaveral.*Station/g, 'Cape Canaveral')
                .split(',')[0];
        }

        function getLaunchStatus(launch) {
            // Status IDs: 3 = Success, 4 = Failure, 7 = Partial Failure
            const statusId = launch.status?.id;
            if (statusId === 3) return 'success';
            if (statusId === 4 || statusId === 7) return 'failure';
            return null;
        }

        function isWithin12Hours(dateStr) {
            const launchTime = new Date(dateStr).getTime();
            const now = Date.now();
            return (now - launchTime) < TWELVE_HOURS;
        }

        async function fetchLaunches() {
            const container = document.getElementById('launches');
            
            try {
                // Fetch both upcoming and recent launches
                const [upcomingRes, previousRes] = await Promise.all([
                    fetch(UPCOMING_URL),
                    fetch(PREVIOUS_URL)
                ]);
                
                if (!upcomingRes.ok) throw new Error('API request failed');
                
                const upcomingData = await upcomingRes.json();
                const upcomingLaunches = upcomingData.results || [];
                
                // Build a map of previous launches by ID for status lookup
                let previousMap = {};
                let recentCompleted = [];
                
                if (previousRes.ok) {
                    const previousData = await previousRes.json();
                    const previousLaunches = previousData.results || [];
                    
                    // Create lookup map and filter recent completed launches
                    previousLaunches.forEach(launch => {
                        previousMap[launch.id] = launch;
                        const status = getLaunchStatus(launch);
                        if (status && isWithin12Hours(launch.net)) {
                            recentCompleted.push(launch);
                        }
                    });
                }
                
                // Get IDs of recent completed launches to avoid duplicates
                const completedIds = new Set(recentCompleted.map(l => l.id));
                
                // Filter upcoming launches to remove any that are in our completed list
                const filteredUpcoming = upcomingLaunches.filter(launch => {
                    // Skip if this launch is already in completed list
                    if (completedIds.has(launch.id)) return false;
                    
                    // Check if this "upcoming" launch actually has a status in previous
                    const previousVersion = previousMap[launch.id];
                    if (previousVersion) {
                        const status = getLaunchStatus(previousVersion);
                        if (status && isWithin12Hours(previousVersion.net)) {
                            // Add the previous version (with status) to completed instead
                            recentCompleted.push(previousVersion);
                            completedIds.add(launch.id);
                            return false;
                        }
                    }
                    return true;
                });
                
                // Sort recent completed by launch time (most recent first)
                recentCompleted.sort((a, b) => new Date(b.net) - new Date(a.net));
                
                // Combine: recent completed first, then upcoming
                let allLaunches = [...recentCompleted, ...filteredUpcoming];
                
                // Remove duplicates by ID (keep first occurrence)
                const seenIds = new Set();
                allLaunches = allLaunches.filter(launch => {
                    if (seenIds.has(launch.id)) return false;
                    seenIds.add(launch.id);
                    return true;
                });
                
                // Limit to 6 total
                allLaunches = allLaunches.slice(0, 6);
                
                if (allLaunches.length === 0) {
                    container.innerHTML = '<div class="error">No launches found</div>';
                    return;
                }

                container.innerHTML = allLaunches.map(launch => {
                    const status = getLaunchStatus(launch);
                    const statusClass = status || '';
                    const countdown = status === 'success' ? 'SUCCESS' : 
                                     status === 'failure' ? 'FAILED' : 
                                     getCountdown(launch.net);
                    const location = shortenLocation(launch.pad?.location?.name);
                    const provider = launch.launch_service_provider?.name || '';
                    
                    return `
                        <div class="launch ${statusClass}">
                            <div class="countdown">${countdown}</div>
                            <div class="launch-info">
                                <div class="mission-name">${launch.name || 'Unknown'}</div>
                                <div class="details">${provider} Â· ${location}</div>
                            </div>
                            <div class="date-time">${formatDate(launch.net)}</div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                container.innerHTML = '<div class="error">Unable to load data</div>';
            }
        }

        fetchLaunches();
        setInterval(fetchLaunches, 15 * 60 * 1000);
    </script>
</body>
</html>
